            ┌───────────┐
            │  Pydantic │
            └─────┬─────┘
                  │
        ┌─────────┴─────────┐
        │                   │
┌──────────────┐   ┌──────────────────┐
│ Data          │   │ Setting          │
│ Validation    │   │ Management       │
└──────┬───────┘   └──────────────────┘
       │
┌──────────────────────────────┐
│ - Data parsing & validation  │
│ - API development            │
│ - Config management          │
│ - Serialization /            │
│   Deserialization            │
└──────────────────────────────┘

 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1) what to note in pydantic:
-import BaseModel
-Type Annotations (int,str,bool etc)
-Model init (Always unpack the dicttonary)
-Automatic Validation ( Pydantic will try to convert to correct data type before raising error. Eg: int="123" -> int = 123)

from pydantic import BaseModel #import BaseModel
class User (BaseModel):
  id: int  #Type Annotations (int,str,bool etc)
  name: str
  is_active: bool
input_data = {'id': 101, 'name': "Chaicode", 'is_active':
True}
user = User(**input_data)  #Model init (Always unpack the dicttonary)
print(user)

 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

2A) Field validator in pydantic is used to check if that particular field has the correct data type
    -need to use @field_validator decorator to check fields
2B) Model validator in pydantic is used to check if the entire model has the correct format
    -need to use @model_validator decorator to check 

 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

3)  Typing in pydantic is used to create a structure for the pydantic to check its elements
Eg: LIST[str], DICT [str] etc

 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
4) Computed property in pydantic:

from pydantic import BaseModel, computed_field, Field
class Product (BaseModel):
            price: float
            quantity:int
@computed_field
@property
def total_price(self) ->float:
            return self.price * self.quantity
class Booking(BaseModel):
            user_id: int
            room_id: int
            nights:int = Field(..., ge = 1 )
            rate_per_night: float
@computed_field
@property
def total_amount(self) ->float:
            return self.nights * self.rate_per_night
booking = Booking(
            user_id=123,
            room_id=456,
            nights=3,
            rate_per_night=100.0
)
print(booking.total_amount)
print(booking.model_dump())


 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
5) Nested Pydantic:

from typing import List, Optional
from pydantic import BaseModel


class Address(BaseModel):
    street: str
    city: str
    postal_code: str

class User(BaseModel):
    id: int
    name: str
    address: Address


address = Address(
    street="123 something",
    city="Jaipur",
    postal_code="100001"
)

user = User(
    id=1,
    name="Hitesh",
    address=address,
)


user_data = {
    "id": 1,
    "name": "Hitesh",
    "address": {
        "street": "321 something",
        "city": "Paris",
        "postal_code": "20002"
    }
}

user = User(**user_data)
print(user)
 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
6) Self referencing models in pydantic

from typing import List, Optional
from pydantic import BaseModel

class Comment(BaseModel):
    id: int
    content: str
    replies: Optional[List['Comment']] = None

Comment.model_rebuild()


comment = Comment(
    id= 1,
    content="First comment",
    replies=[
        Comment(id=2, content="reply 1"),
        Comment(id=3, content="reply 2", replies=[
            Comment(id=4, content="nested reply")
        ])
    ]
)

 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

7) Advanced nested models:

from pydantic import BaseModel
from typing import Optional, List, Union


class Address(BaseModel):
    street: str
    city: str
    postal_code: str

class Company(BaseModel):
    name: str
    address: Optional[Address] = None

class Employee(BaseModel):
    name: str
    company: Optional[Company] = None


class TextConent(BaseModel):
    type: str = "text"
    content: str

class ImageContent(BaseModel):
    type: str = "Image"
    url: str
    alt_text: str

class Article(BaseModel):
    title: str
    sections: List[Union[TextConent, ImageContent]]


class Country(BaseModel):
    name: str
    code: str

class State(BaseModel):
    name: str
    country: Country

class City(BaseModel):
    name: str
    state: State

class Address(BaseModel):
    street: str
    city: City
    postal_code: str

class Organization(BaseModel):
    name: str
    head_quarter: Address
    branches: List[Address]=[]

 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 8)Best Practices:
    Model Organization
            1. Define leaf models first - Models with no dependencies
            2. Build upward - Gradually compose more complex models
            3. Use clear naming - Make relationships obvious
             4. Group related models - Keep models in logical modules
Performance Considerations
            1. Deep nesting impacts performance - Keep reasonable depth
            2. Large lists of nested models - Consider pagination
            3. Circular references - Use carefully, can cause memory issues
            4. Lazy loading - Consider for expensive nested computations
Data Modeling Tips
            1. Model real-world relationships - Mirror your domain structure
            2. Use Optional appropriately - Not all relationships are required A
            3. Consider Union types - For polymorphic relationships
            4. Validate business rules - Use model validators for cross-model logic

 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

9) Serialization in pydantic:

from pydantic import BaseModel, ConfigDict
from typing import List
from datetime import datetime


class Address(BaseModel):
    street: str
    city: str
    zip_code: str

class User(BaseModel):
    id: int
    name: str
    email: str
    is_active: bool = True
    createdAt: datetime
    address: Address
    tags: List[str] = []

    model_config = ConfigDict(
        json_encoders={datetime: lambda v: v.strftime('%d-%m-%Y %H:%M:%S')}
    )


user = User(
    id=1,
    name="Hitesh",
    email="h@hitesh.ai",
    createdAt=datetime(2024, 3, 15, 14, 30,),
    address=Address(
        street="Something",
        city="Jaipur",
        zip_code="009988"
    ),
    is_active=False,
    tags=["premium", "subscriber"]
)

python_dict = user.model_dump()
print(user)
print("="*30)
print(python_dict)

json_str = user.model_dump_json()
print("="*30)
print(json_str)

 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
