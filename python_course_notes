1) *kwargs usage:    
def special_chai(*ingredients, **extras)://*kwargs
      print("Ingredients", ingredients)
      print("Extras", extras)
   special_chai("Cinnamon", "Cardmom", sweetener="Honey", foam="yes")
  
  -> output:
    Ingredients ('Cinnamon', 'Cardmom')
    Extras {'sweetener': 'Honey', 'foam': 'yes'}

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

2) Correct use of nonlocal:
  def happy():
    x = 20     # enclosing variable

    def happy2():
        nonlocal x
        x = 30

    happy2()
    print(x)//30

happy()

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

3) Correct use of global:
x = 10

def happy():
    global x
    x = 20

    def happy2():
        global x
        x = 30

    happy2()

happy()
print(x)//30

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  
4) Dunder usage:

    def chai_flavor(flavor="masala"):
        """Return the flavor of chai."""
        return flavor

    print(chai_flavor._doc_)
    print(chai_flavor._name__)

    ->OUTPUT:
    Return the flavor of chai.
    chai_flavor

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  5) Comprehensions in python:
    - used to shorten ur code writing
    - faster execution and less code lines
    - 3 types:
              -list 
              -set
              -dictionary

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


6) Generators and their usage:
    - yield : to have a whole bunch of data
    - next() -  more like iteratiing through the generator
    - send() -  sending data into the generator
    - yield from - taking values from other yield statements (sub generators)
    - close - to close the generator (good practice)

  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

7) Decorators:

def my_decorator (func):
  def wrapper():
    print("Before function runs")
    func()
    print("After function runs")
  return wrapper

@my_decorator
def greet():
  print("Hello from decorators class from chaicode")
greet()

-> OUTPUT:
  Before function runs
  Hello from decorators class from chaicode
  After function runs
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

8) Asyncio python programming:
      -async def: coroutines
      -await: pause execution until result is obtained
      -ayncio: build in python library
      -event loop: engine that runs and schedules coroutines
- it is used in FASTAPI to run requests faster
-Also used as non blocking for any execution

->import asyncio
  async def brew_chai():
        print("Brwing chai...")
        await asyncio.sleep(2)
        print("Chai is ready")
  asyncio.run(brew_chai())

-> asyncio with threads:
import asyncio
import time
from concurrent.futures import ThreadPoolExecutor
def check_stock(item):
      print(f"Checking {item}.in-store...")
      time.sleep(3) # Blocking operation
      return f"{item} stock: -42"
async def main():
      loop = asyncio.get_running_loop()
      with ThreadPoolExecutor as pool:
            result = await loop.run_in_executor(pool,
            check_stock, "Masala chai")
            print(result)
asyncio.run(main())

->asyncio with process:
import asyncio
from concurrent.futures import ProcessPoolExecutor
def encrypt(data):
      return f" {data[::-1]}"
async def main():
      loop = asyncio.get_running_loop()
      with ProcessPoolExecutor() as pool:
            result = await loop.run_in_executor (pool, encrypt,
            "credit_card_1234")
      print(f"{result}")
if __name_ "__main__":
      asyncio.run(main())

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

9) profiling, debugging race condition tools:
-pyspy
-vprof
-Thread Scope

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

